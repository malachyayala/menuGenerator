#!/usr/bin/env python3
import csv
import argparse
import logging
from pathlib import Path
from typing import Dict, Any, Optional
from google import genai
import os
from datetime import datetime
from dotenv import load_dotenv
import yaml
import sys

def setup_logging(log_level: int = logging.INFO) -> None:
    """Configure logging for the application."""
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('meal_planner.log')
        ]
    )

def load_config(config_path: Path) -> Dict[str, Any]:
    """Loads the YAML configuration file.
    
    Args:
        config_path: Path to the configuration file
        
    Returns:
        Dictionary containing configuration settings
        
    Raises:
        SystemExit: If file not found or parsing error occurs
    """
    logger = logging.getLogger(__name__)
    try:
        with open(config_path, 'r') as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        logger.error(f"Configuration file not found at {config_path}")
        sys.exit(1)
    except yaml.YAMLError as e:
        logger.error(f"Error parsing YAML file: {e}")
        sys.exit(1)

def read_csv_data(csv_filepath: Path) -> str:
    """Read CSV file and convert to string format.
    
    Args:
        csv_filepath: Path to the CSV file
        
    Returns:
        String containing CSV data
        
    Raises:
        SystemExit: If file not found
    """
    logger = logging.getLogger(__name__)
    try:
        with open(csv_filepath, 'r') as file:
            reader = csv.reader(file)
            return '\n'.join([','.join(row) for row in reader])
    except FileNotFoundError:
        logger.error(f"CSV file not found at {csv_filepath}")
        sys.exit(1)

def init_genai_client(api_key: Optional[str] = None) -> genai.Client:
    """Initialize the Gemini API client.
    
    Args:
        api_key: Optional API key, if not provided will look in environment
        
    Returns:
        Initialized Gemini client
        
    Raises:
        ValueError: If API key is not available
    """
    if not api_key:
        api_key = os.getenv('GEMINI_API_KEY')
    if not api_key:
        raise ValueError("GEMINI_API_KEY environment variable is not set")
    return genai.Client(api_key=api_key)

def format_prompt(config: Dict[str, Any], csv_data: str) -> str:
    """Format the prompt using configuration and CSV data.
    
    Args:
        config: Configuration dictionary
        csv_data: String containing CSV data
        
    Returns:
        Formatted prompt string
    """
    return config['prompt_template'].format(
        csv_data=csv_data,
        servings=config['preferences']['servings'],
        dietary=config['preferences']['dietary'],
        cuisine=config['preferences']['cuisine'],
        other_notes=config['preferences']['other_notes']
    )

def generate_content(client: genai.Client, prompt: str, model: str) -> str:
    """Generate content using the Gemini API.
    
    Args:
        client: Initialized Gemini client
        prompt: Formatted prompt string
        model: Model name to use
        
    Returns:
        Generated content
        
    Raises:
        SystemExit: If API communication fails
    """
    logger = logging.getLogger(__name__)
    try:
        response = client.models.generate_content(
            model=model, contents=prompt
        )
        return response.text
    except Exception as e:
        logger.error(f"Error communicating with the generative model API: {e}")
        sys.exit(1)

def save_meal_plan(content: str, base_path: Path, output_dir: str) -> Path:
    """Save the generated meal plan to a file.
    
    Args:
        content: Generated meal plan content
        base_path: Base path for output directory
        output_dir: Name of output directory
        
    Returns:
        Path to the saved file
        
    Raises:
        SystemExit: If writing to file fails
    """
    logger = logging.getLogger(__name__)
    output_path = base_path / output_dir
    output_path.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')
    output_file = output_path / f'meal_plan_{timestamp}.md'
    
    try:
        output_file.write_text(content)
        logger.info(f"Meal plan generated and saved to: {output_file}")
        return output_file
    except IOError as e:
        logger.error(f"Error writing to output file {output_file}: {e}")
        sys.exit(1)

def generate_meal_plan(csv_filepath: Path) -> None:
    """Main function to generate meal plan.
    
    Args:
        csv_filepath: Path to input CSV file
    """
    logger = logging.getLogger(__name__)
    
    # Load environment variables and config
    load_dotenv()
    script_dir = Path(__file__).parent
    config = load_config(script_dir / 'config.yaml')
    
    # Initialize components
    client = init_genai_client()
    csv_data = read_csv_data(csv_filepath)
    prompt = format_prompt(config, csv_data)
    
    # Generate and save content
    content = generate_content(client, prompt, config['llm']['model'])
    save_meal_plan(content, csv_filepath.parent, config['output']['directory_name'])

def main() -> None:
    """Entry point of the script."""
    # Setup argument parser
    parser = argparse.ArgumentParser(description='Generate a weekly meal plan based on kitchen inventory')
    parser.add_argument('csv_path', type=Path, help='Path to the kitchen inventory CSV file')
    parser.add_argument('--log-level', type=str, default='INFO',
                       choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                       help='Set the logging level')
    args = parser.parse_args()
    
    # Setup logging
    setup_logging(getattr(logging, args.log_level))
    logger = logging.getLogger(__name__)
    
    try:
        generate_meal_plan(args.csv_path)
    except Exception as e:
        logger.exception(f"An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()